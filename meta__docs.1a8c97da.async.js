"use strict";(self.webpackChunkScrollBar=self.webpackChunkScrollBar||[]).push([[904],{43311:function(m,n,e){var d;e.r(n),e.d(n,{demos:function(){return B}});var E=e(90228),t=e.n(E),p=e(87999),i=e.n(p),l=e(75271),r=e(68455),f=e(1075),c=e(39826),o=e(31302),k=e(64993),g=e(37967),D=e(78123),x=e(6475),v=e(67811),M=e(64720),T=e(64417),N=e(37231),K=e(28661),B={"docs-example-demo-basic":{component:l.memo(l.lazy(function(){return e.e(433).then(e.bind(e,90876))})),asset:{type:"BLOCK",id:"docs-example-demo-basic",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(36933).Z},react:{type:"NPM",value:"18.3.1"},"../../assets/style.less":{type:"FILE",value:e(39067).Z},"../../src.tsx":{type:"FILE",value:e(27863).Z},"./ScrollBar.tsx":{type:"FILE",value:e(10700).Z},"./context.ts":{type:"FILE",value:e(79507).Z},"./utils.ts":{type:"FILE",value:e(9143).Z},"./hooks.ts":{type:"FILE",value:e(36546).Z},"./bar.tsx":{type:"FILE",value:e(32390).Z},"./useEventListener.ts":{type:"FILE",value:e(66476).Z},"./useResizeObserver.ts":{type:"FILE",value:e(35130).Z},"./Thumb.tsx":{type:"FILE",value:e(75998).Z},"./util.ts":{type:"FILE",value:e(99547).Z}},entry:"index.tsx"},context:{"../../assets/style.less":r,"../../src.tsx":f,"./ScrollBar.tsx":c,"./context.ts":o,"./utils.ts":k,"./hooks.ts":g,"./bar.tsx":D,"./useEventListener.ts":x,"./useResizeObserver.ts":v,"./Thumb.tsx":M,"./util.ts":T,react:d||(d=e.t(l,2)),"/Users/thinkerwing/Desktop/background/ScrollBar/assets/style.less":r,"/Users/thinkerwing/Desktop/background/ScrollBar/src/index.tsx":f,"/Users/thinkerwing/Desktop/background/ScrollBar/src/ScrollBar.tsx":c,"/Users/thinkerwing/Desktop/background/ScrollBar/src/context.ts":o,"/Users/thinkerwing/Desktop/background/ScrollBar/src/utils/index.ts":k,"/Users/thinkerwing/Desktop/background/ScrollBar/src/hooks/index.ts":g,"/Users/thinkerwing/Desktop/background/ScrollBar/src/bar.tsx":D,"/Users/thinkerwing/Desktop/background/ScrollBar/src/hooks/useEventListener.ts":x,"/Users/thinkerwing/Desktop/background/ScrollBar/src/hooks/useResizeObserver.ts":v,"/Users/thinkerwing/Desktop/background/ScrollBar/src/Thumb.tsx":M,"/Users/thinkerwing/Desktop/background/ScrollBar/src/util.ts":T},renderOpts:{compile:function(){var w=i()(t()().mark(function O(){var _,S=arguments;return t()().wrap(function(s){for(;;)switch(s.prev=s.next){case 0:return s.next=2,e.e(153).then(e.bind(e,58153));case 2:return s.abrupt("return",(_=s.sent).default.apply(_,S));case 3:case"end":return s.stop()}},O)}));function P(){return w.apply(this,arguments)}return P}()}},"docs-example-demo-horizontal":{component:l.memo(l.lazy(function(){return e.e(433).then(e.bind(e,51429))})),asset:{type:"BLOCK",id:"docs-example-demo-horizontal",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(7575).Z},react:{type:"NPM",value:"18.3.1"},"../../src.tsx":{type:"FILE",value:e(27863).Z},"./ScrollBar.tsx":{type:"FILE",value:e(10700).Z},"./context.ts":{type:"FILE",value:e(79507).Z},"./utils.ts":{type:"FILE",value:e(9143).Z},"./bar.tsx":{type:"FILE",value:e(32390).Z},"./hooks.ts":{type:"FILE",value:e(36546).Z},"./useEventListener.ts":{type:"FILE",value:e(66476).Z},"./useResizeObserver.ts":{type:"FILE",value:e(35130).Z},"./Thumb.tsx":{type:"FILE",value:e(75998).Z},"./util.ts":{type:"FILE",value:e(99547).Z}},entry:"index.tsx"},context:{"../../src.tsx":f,"./ScrollBar.tsx":c,"./context.ts":o,"./utils.ts":k,"./bar.tsx":D,"./hooks.ts":g,"./useEventListener.ts":x,"./useResizeObserver.ts":v,"./Thumb.tsx":M,"./util.ts":T,react:d||(d=e.t(l,2)),"/Users/thinkerwing/Desktop/background/ScrollBar/src/index.tsx":f,"/Users/thinkerwing/Desktop/background/ScrollBar/src/ScrollBar.tsx":c,"/Users/thinkerwing/Desktop/background/ScrollBar/src/context.ts":o,"/Users/thinkerwing/Desktop/background/ScrollBar/src/utils/index.ts":k,"/Users/thinkerwing/Desktop/background/ScrollBar/src/bar.tsx":D,"/Users/thinkerwing/Desktop/background/ScrollBar/src/hooks/index.ts":g,"/Users/thinkerwing/Desktop/background/ScrollBar/src/hooks/useEventListener.ts":x,"/Users/thinkerwing/Desktop/background/ScrollBar/src/hooks/useResizeObserver.ts":v,"/Users/thinkerwing/Desktop/background/ScrollBar/src/Thumb.tsx":M,"/Users/thinkerwing/Desktop/background/ScrollBar/src/util.ts":T},renderOpts:{compile:function(){var w=i()(t()().mark(function O(){var _,S=arguments;return t()().wrap(function(s){for(;;)switch(s.prev=s.next){case 0:return s.next=2,e.e(153).then(e.bind(e,58153));case 2:return s.abrupt("return",(_=s.sent).default.apply(_,S));case 3:case"end":return s.stop()}},O)}));function P(){return w.apply(this,arguments)}return P}()}},"docs-example-demo-manual":{component:l.memo(l.lazy(function(){return e.e(433).then(e.bind(e,43082))})),asset:{type:"BLOCK",id:"docs-example-demo-manual",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(35324).Z},react:{type:"NPM",value:"18.3.1"},"rc-slider":{type:"NPM",value:"11.1.8"},"../../assets/style.less":{type:"FILE",value:e(39067).Z},"../../src.tsx":{type:"FILE",value:e(27863).Z},"./ScrollBar.tsx":{type:"FILE",value:e(10700).Z},"./context.ts":{type:"FILE",value:e(79507).Z},"./bar.tsx":{type:"FILE",value:e(32390).Z},"./hooks.ts":{type:"FILE",value:e(36546).Z},"./utils.ts":{type:"FILE",value:e(9143).Z},"./useEventListener.ts":{type:"FILE",value:e(66476).Z},"./useResizeObserver.ts":{type:"FILE",value:e(35130).Z},"./Thumb.tsx":{type:"FILE",value:e(75998).Z},"./util.ts":{type:"FILE",value:e(99547).Z}},entry:"index.tsx"},context:{"../../assets/style.less":r,"../../src.tsx":f,"./ScrollBar.tsx":c,"./context.ts":o,"./bar.tsx":D,"./hooks.ts":g,"./utils.ts":k,"./useEventListener.ts":x,"./useResizeObserver.ts":v,"./Thumb.tsx":M,"./util.ts":T,react:d||(d=e.t(l,2)),"rc-slider/assets/index.css":N,"rc-slider":K,"/Users/thinkerwing/Desktop/background/ScrollBar/assets/style.less":r,"/Users/thinkerwing/Desktop/background/ScrollBar/src/index.tsx":f,"/Users/thinkerwing/Desktop/background/ScrollBar/src/ScrollBar.tsx":c,"/Users/thinkerwing/Desktop/background/ScrollBar/src/context.ts":o,"/Users/thinkerwing/Desktop/background/ScrollBar/src/bar.tsx":D,"/Users/thinkerwing/Desktop/background/ScrollBar/src/hooks/index.ts":g,"/Users/thinkerwing/Desktop/background/ScrollBar/src/utils/index.ts":k,"/Users/thinkerwing/Desktop/background/ScrollBar/src/hooks/useEventListener.ts":x,"/Users/thinkerwing/Desktop/background/ScrollBar/src/hooks/useResizeObserver.ts":v,"/Users/thinkerwing/Desktop/background/ScrollBar/src/Thumb.tsx":M,"/Users/thinkerwing/Desktop/background/ScrollBar/src/util.ts":T},renderOpts:{compile:function(){var w=i()(t()().mark(function O(){var _,S=arguments;return t()().wrap(function(s){for(;;)switch(s.prev=s.next){case 0:return s.next=2,e.e(153).then(e.bind(e,58153));case 2:return s.abrupt("return",(_=s.sent).default.apply(_,S));case 3:case"end":return s.stop()}},O)}));function P(){return w.apply(this,arguments)}return P}()}},"docs-example-demo-infinite":{component:l.memo(l.lazy(function(){return e.e(433).then(e.bind(e,14720))})),asset:{type:"BLOCK",id:"docs-example-demo-infinite",refAtomIds:[],dependencies:{"index.tsx":{type:"FILE",value:e(32620).Z},react:{type:"NPM",value:"18.3.1"},"../../assets/style.less":{type:"FILE",value:e(39067).Z},"../../src.tsx":{type:"FILE",value:e(27863).Z},"./ScrollBar.tsx":{type:"FILE",value:e(10700).Z},"./utils.ts":{type:"FILE",value:e(9143).Z},"./hooks.ts":{type:"FILE",value:e(36546).Z},"./bar.tsx":{type:"FILE",value:e(32390).Z},"./context.ts":{type:"FILE",value:e(79507).Z},"./useEventListener.ts":{type:"FILE",value:e(66476).Z},"./useResizeObserver.ts":{type:"FILE",value:e(35130).Z},"./Thumb.tsx":{type:"FILE",value:e(75998).Z},"./util.ts":{type:"FILE",value:e(99547).Z}},entry:"index.tsx"},context:{"../../assets/style.less":r,"../../src.tsx":f,"./ScrollBar.tsx":c,"./utils.ts":k,"./hooks.ts":g,"./bar.tsx":D,"./context.ts":o,"./useEventListener.ts":x,"./useResizeObserver.ts":v,"./Thumb.tsx":M,"./util.ts":T,react:d||(d=e.t(l,2)),"/Users/thinkerwing/Desktop/background/ScrollBar/assets/style.less":r,"/Users/thinkerwing/Desktop/background/ScrollBar/src/index.tsx":f,"/Users/thinkerwing/Desktop/background/ScrollBar/src/ScrollBar.tsx":c,"/Users/thinkerwing/Desktop/background/ScrollBar/src/utils/index.ts":k,"/Users/thinkerwing/Desktop/background/ScrollBar/src/hooks/index.ts":g,"/Users/thinkerwing/Desktop/background/ScrollBar/src/bar.tsx":D,"/Users/thinkerwing/Desktop/background/ScrollBar/src/context.ts":o,"/Users/thinkerwing/Desktop/background/ScrollBar/src/hooks/useEventListener.ts":x,"/Users/thinkerwing/Desktop/background/ScrollBar/src/hooks/useResizeObserver.ts":v,"/Users/thinkerwing/Desktop/background/ScrollBar/src/Thumb.tsx":M,"/Users/thinkerwing/Desktop/background/ScrollBar/src/util.ts":T},renderOpts:{compile:function(){var w=i()(t()().mark(function O(){var _,S=arguments;return t()().wrap(function(s){for(;;)switch(s.prev=s.next){case 0:return s.next=2,e.e(153).then(e.bind(e,58153));case 2:return s.abrupt("return",(_=s.sent).default.apply(_,S));case 3:case"end":return s.stop()}},O)}));function P(){return w.apply(this,arguments)}return P}()}}}},11676:function(m,n,e){e.r(n),e.d(n,{demos:function(){return E}});var d=e(75271),E={}},39826:function(m,n,e){e.r(n);var d=e(26068),E=e.n(d),t=e(75271),p=e(37967),i=e(64993),l=e(78123),r=e(31302),f=e(52676),c=t.forwardRef(function(o,k){var g=o.height,D=o.maxHeight,x=o.native,v=x===void 0?!1:x,M=o.wrapStyle,T=M===void 0?{}:M,N=o.wrapClass,K=N===void 0?"":N,B=o.viewClass,w=B===void 0?"":B,P=o.viewStyle,O=P===void 0?{}:P,_=o.noresize,S=_===void 0?!1:_,z=o.tag,s=z===void 0?"div":z,A=o.always,b=A===void 0?!1:A,R=o.minSize,H=R===void 0?12:R,G=o.tabindex,Z=o.id,X=o.role,Y=o.ariaLabel,ee=o.ariaOrientation,ne=o.children,j=o.onScroll,W=o.onEndReached,F=(0,p.useNamespace)("scrollbar"),te=(0,t.useRef)(null),y=(0,t.useRef)(null),re=(0,t.useRef)(null),u=(0,t.useRef)(null),V=(0,t.useRef)(0),I=(0,t.useRef)(0),Q=(0,t.useRef)("top"),J=(0,t.useRef)(),se=(0,t.useRef)(),le=t.useMemo(function(){var a=E()({},T);return g&&(a.height=(0,i.addUnit)(g)),D&&(a.maxHeight=(0,i.addUnit)(D)),a},[g,D,T]),me=t.useMemo(function(){return[K,F.e("wrap"),v?"":F.em("wrap","hidden-default")].filter(Boolean).join(" ")},[K,F,v]),fe=t.useMemo(function(){return[F.e("view"),w].filter(Boolean).join(" ")},[F,w]),ie=(0,t.useCallback)(function(a,U,$,ve,oe){var de=1;return{bottom:U+a.clientHeight>=a.scrollHeight-de,top:U<=de,right:$+a.clientWidth>=a.scrollWidth-de,left:$<=de}},[]),ae=(0,t.useCallback)(function(){if(y.current){var a;(a=u.current)===null||a===void 0||a.handleScroll(y.current);var U=V.current,$=I.current;V.current=y.current.scrollTop,I.current=y.current.scrollLeft;var ve=ie(y.current,V.current,I.current,U,$),oe=Q.current;Math.abs(U-V.current)>Math.abs($-I.current)?oe=V.current>U?"bottom":"top":$!==I.current&&(oe=I.current>$?"right":"left"),Q.current=oe,j==null||j({scrollTop:V.current,scrollLeft:I.current}),ve[oe]&&(W==null||W(oe))}},[j,W,ie]),ce=(0,t.useCallback)(function(a,U){if(!y.current){console.warn("Scrollbar wrap element is not available");return}try{(0,i.isObject)(a)?y.current.scrollTo(a):(0,i.isNumber)(a)&&(0,i.isNumber)(U)?y.current.scrollTo(a,U):console.warn("Invalid arguments for scrollTo")}catch($){console.error("ScrollTo failed:",$)}},[]),ue=(0,t.useCallback)(function(a){if(!(0,i.isNumber)(a)){console.warn("ElScrollbar: value must be a number");return}y.current&&(y.current.scrollTop=a)},[]),L=(0,t.useCallback)(function(a){if(!(0,i.isNumber)(a)){console.warn("ElScrollbar: value must be a number");return}y.current&&(y.current.scrollLeft=a)},[]),h=(0,t.useCallback)(function(){var a;(a=u.current)===null||a===void 0||a.update()},[]),C=(0,p.useResizeObserver)(re,!S);(0,p.useEventListener)(S?null:window,"resize",h),(0,t.useEffect)(function(){C&&!S&&h()},[C,S,h]),(0,t.useEffect)(function(){v||setTimeout(function(){if(h(),y.current){var a;(a=u.current)===null||a===void 0||a.handleScroll(y.current)}},0)},[D,g,v,h]),(0,t.useEffect)(function(){v||setTimeout(function(){h()},0)},[v,h]),(0,t.useEffect)(function(){return function(){var a,U;(a=J.current)===null||a===void 0||a.call(J),(U=se.current)===null||U===void 0||U.call(se)}},[]);var q=t.useMemo(function(){return{scrollbarElement:te.current,wrapElement:y.current}},[te.current,y.current]);return t.useImperativeHandle(k,function(){return{wrapRef:y,update:h,scrollTo:ce,setScrollTop:ue,setScrollLeft:L,handleScroll:ae}},[h,ce,ue,L,ae]),(0,f.jsx)(r.ScrollbarContext.Provider,{value:q,children:(0,f.jsxs)("div",{ref:te,className:F.b(),children:[(0,f.jsx)("div",{ref:y,className:me,style:le,tabIndex:G,onScroll:ae,children:(0,f.jsx)("div",{id:Z,ref:re,className:fe,style:O,role:X,"aria-label":Y,"aria-orientation":ee,children:ne})}),!v&&(0,f.jsx)(l.default,{ref:u,always:b,minSize:H})]})})});c.displayName="Scrollbar",n.default=c},64720:function(m,n,e){e.r(n);var d=e(82092),E=e.n(d),t=e(26068),p=e.n(t),i=e(48305),l=e.n(i),r=e(75271),f=e(37967),c=e(64993),o=e(31302),k=e(64417),g=e(52676),D="Thumb",x=(0,r.forwardRef)(function(v,M){var T=v.vertical,N=T===void 0?!1:T,K=v.size,B=K===void 0?"":K,w=v.move,P=w===void 0?0:w,O=v.ratio,_=O===void 0?1:O,S=v.always,z=S===void 0?!1:S,s=r.useContext(o.ScrollbarContext),A=(0,f.useNamespace)("scrollbar");if(!s)throw new Error("".concat(D,": can not inject scrollbar context"));var b=(0,r.useRef)(null),R=(0,r.useRef)(null),H=(0,r.useState)({}),G=l()(H,2),Z=G[0],X=G[1],Y=(0,r.useState)(!1),ee=l()(Y,2),ne=ee[0],j=ee[1],W=(0,r.useRef)(!1),F=(0,r.useRef)(!1),te=(0,r.useRef)(0),y=(0,r.useRef)(0),re=(0,r.useRef)((0,c.isClient)()?document.onselectstart:null),u=(0,r.useMemo)(function(){return k.BAR_MAP[N?"vertical":"horizontal"]},[N]),V=(0,r.useMemo)(function(){return(0,k.renderThumbStyle)({size:B,move:P,bar:u})},[B,P,u]),I=(0,r.useMemo)(function(){if(!b.current||!R.current||!s.wrapElement)return 1;var L=b.current[u.offset],h=s.wrapElement[u.scrollSize],C=R.current[u.offset];return L===0||h===0||C===0||_===0?1:Math.pow(L,2)/h/_/C},[u,_,s.wrapElement]),Q=(0,r.useCallback)(function(){document.onselectstart!==re.current&&(document.onselectstart=re.current)},[]),J=(0,r.useCallback)(function(){W.current=!1,document.removeEventListener("mousemove",se),document.removeEventListener("mouseup",J),Q(),F.current&&j(!1)},[u.axis,Q]),se=(0,r.useCallback)(function(L){if(!(!b.current||!R.current||!s.wrapElement)&&W.current!==!1){var h=Z[u.axis];if(h){var C=(b.current.getBoundingClientRect()[u.direction]-L[u.client])*-1,q=R.current[u.offset]-h,a=(C-q)*100*I/b.current[u.offset];u.scroll==="scrollLeft"?s.wrapElement[u.scroll]=a*y.current/100:s.wrapElement[u.scroll]=a*te.current/100}}},[Z,u,I,s.wrapElement]),le=(0,r.useCallback)(function(L){s.wrapElement&&(L.stopImmediatePropagation(),W.current=!0,te.current=s.wrapElement.scrollHeight,y.current=s.wrapElement.scrollWidth,document.addEventListener("mousemove",se),document.addEventListener("mouseup",J),re.current=document.onselectstart,document.onselectstart=function(){return!1})},[s.wrapElement,se,J]),me=(0,r.useCallback)(function(L){var h;if(L.stopPropagation(),!(L.ctrlKey||[1,2].includes(L.button))){(h=window.getSelection())===null||h===void 0||h.removeAllRanges(),le(L.nativeEvent);var C=L.currentTarget;if(C){var q=p()(p()({},Z),{},E()({},u.axis,C[u.offset]-(L.nativeEvent[u.client]-C.getBoundingClientRect()[u.direction])));X(q)}}},[le,Z,u]),fe=(0,r.useCallback)(function(L){if(!(!R.current||!b.current||!s.wrapElement)){var h=L.target,C=Math.abs(h.getBoundingClientRect()[u.direction]-L.nativeEvent[u.client]),q=R.current[u.offset]/2,a=(C-q)*100*I/b.current[u.offset];s.wrapElement[u.scroll]=a*s.wrapElement[u.scrollSize]/100}},[u,I,s.wrapElement]),ie=(0,r.useCallback)(function(){F.current=!1,j(!!B)},[B]),ae=(0,r.useCallback)(function(){F.current=!0,j(W.current)},[]);(0,f.useEventListener)(s.scrollbarElement,"mousemove",ie),(0,f.useEventListener)(s.scrollbarElement,"mouseleave",ae),(0,r.useEffect)(function(){return function(){Q(),document.removeEventListener("mouseup",J)}},[Q,J]),(0,r.useImperativeHandle)(M,function(){return{}},[]);var ce="".concat(A.e("bar")," ").concat(A.is(u.key)),ue=A.e("thumb");return(0,g.jsx)("div",{ref:b,className:ce,style:{opacity:z||ne?1:0,transition:"opacity 120ms ease-out",display:z||ne?"block":"none"},onMouseDown:fe,onClick:function(h){return h.stopPropagation()},children:(0,g.jsx)("div",{ref:R,className:ue,style:V,onMouseDown:me})})});x.displayName="Thumb",n.default=x},78123:function(m,n,e){e.r(n);var d=e(48305),E=e.n(d),t=e(75271),p=e(64720),i=e(64417),l=e(31302),r=e(52676),f=t.forwardRef(function(c,o){var k=c.minSize,g=k===void 0?12:k,D=c.always,x=D===void 0?!1:D,v=t.useContext(l.ScrollbarContext),M=t.useRef(0),T=t.useRef(0),N=t.useRef(""),K=t.useRef(""),B=t.useRef(1),w=t.useRef(1),P=t.useReducer(function(A){return A+1},0),O=E()(P,2),_=O[1],S=function(b,R){return R===0?1:b/R},z=function(b){if(b){var R=b.offsetHeight-i.GAP,H=b.offsetWidth-i.GAP;T.current=R===0?0:b.scrollTop*100/R*B.current,M.current=H===0?0:b.scrollLeft*100/H*w.current,_()}},s=function(){var b=v==null?void 0:v.wrapElement;if(b){var R=b.offsetHeight-i.GAP,H=b.offsetWidth-i.GAP,G=S(Math.pow(R,2),b.scrollHeight),Z=S(Math.pow(H,2),b.scrollWidth),X=Math.max(G,g),Y=Math.max(Z,g),ee=R-G,ne=R-X,j=H-Z,W=H-Y;B.current=S(G,ee)/S(X,ne),w.current=S(Z,j)/S(Y,W),K.current=X+i.GAP<R?"".concat(X,"px"):"",N.current=Y+i.GAP<H?"".concat(Y,"px"):"",_()}};return t.useImperativeHandle(o,function(){return{handleScroll:z,update:s}}),(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(p.default,{move:M.current,ratio:w.current,size:N.current,always:x}),(0,r.jsx)(p.default,{move:T.current,ratio:B.current,size:K.current,vertical:!0,always:x})]})});f.displayName="Bar",n.default=f},31302:function(m,n,e){e.r(n),e.d(n,{ScrollbarContext:function(){return E}});var d=e(75271),E=d.createContext(null)},37967:function(m,n,e){e.r(n),e.d(n,{useEventListener:function(){return E.default},useNamespace:function(){return t},useResizeObserver:function(){return d.default}});var d=e(67811),E=e(6475),t=function(i){return{b:function(){return"el-".concat(i)},e:function(r){return"el-".concat(i,"__").concat(r)},em:function(r,f){return"el-".concat(i,"__").concat(r,"--").concat(f)},is:function(r){return r?"is-".concat(r):""}}}},6475:function(m,n,e){e.r(n);var d=e(75271),E=function(p,i,l){return(0,d.useEffect)(function(){if(p)return p.addEventListener(i,l),function(){p.removeEventListener(i,l)}},[p,i,l]),function(){p&&p.removeEventListener(i,l)}};n.default=E},67811:function(m,n,e){e.r(n);var d=e(48305),E=e.n(d),t=e(75271),p=function(l){var r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0,f=(0,t.useState)(null),c=E()(f,2),o=c[0],k=c[1];return(0,t.useEffect)(function(){if(!(!r||!l.current)){var g=new ResizeObserver(function(D){var x=D[0].contentRect,v=x.width,M=x.height;k({width:v,height:M})});return g.observe(l.current),function(){g.disconnect()}}},[l,r]),o};n.default=p},1075:function(m,n,e){e.r(n);var d=e(39826);n.default=d.default},64417:function(m,n,e){e.r(n),e.d(n,{BAR_MAP:function(){return p},GAP:function(){return t},renderThumbStyle:function(){return i}});var d=e(82092),E=e.n(d),t=4,p={vertical:{offset:"offsetHeight",scroll:"scrollTop",scrollSize:"scrollHeight",size:"height",key:"vertical",axis:"Y",client:"clientY",direction:"top"},horizontal:{offset:"offsetWidth",scroll:"scrollLeft",scrollSize:"scrollWidth",size:"width",key:"horizontal",axis:"X",client:"clientX",direction:"left"}},i=function(r){var f=r.move,c=r.size,o=r.bar;return E()(E()({},o.size,c),"transform","translate".concat(o.axis,"(").concat(f,"%)"))}},64993:function(m,n,e){e.r(n),e.d(n,{addUnit:function(){return r},isClient:function(){return f},isNumber:function(){return t},isObject:function(){return i},isString:function(){return p},isStringNumber:function(){return l}});var d=e(31759),E=e.n(d),t=function(o){return typeof o=="number"},p=function(o){return typeof o=="string"};function i(c){return c!==null&&E()(c)==="object"}var l=function(o){return p(o)?!Number.isNaN(Number(o)):!1};function r(c){var o=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"px";if(!c)return"";if(t(c)||l(c))return"".concat(c).concat(o);if(p(c))return c;console.error("binding value must be a string or number")}function f(){return typeof window!="undefined"&&typeof document!="undefined"}},68455:function(m,n,e){e.r(n)},62775:function(m,n,e){e.r(n),e.d(n,{texts:function(){return d}});const d=[{value:"Use ",paraId:0,tocIndex:2},{value:"setScrollTop",paraId:0,tocIndex:2},{value:" and ",paraId:0,tocIndex:2},{value:"setScrollLeft",paraId:0,tocIndex:2},{value:" methods can control scrollbar manually.",paraId:0,tocIndex:2},{value:"end-reached",paraId:1,tocIndex:3},{value:" is triggered when the scrollbar reaches the end. It can be used as an infinite scroll.",paraId:1,tocIndex:3}]},32683:function(m,n,e){e.r(n),e.d(n,{texts:function(){return d}});const d=[{value:`npm install
npm start
`,paraId:0,tocIndex:0}]},39067:function(m,n){n.Z=`@import './index.less';

// reset
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

.wrapper {
  margin-bottom: 10px;
}

// scrollbar.less
@namespace: el;

// CSS \u53D8\u91CF\u5B9A\u4E49
:root {
  --el-scrollbar-bg-color: rgba(144, 147, 153, 0.3);
  --el-scrollbar-hover-bg-color: rgba(144, 147, 153, 0.5);
  --el-scrollbar-opacity: 0.8;
  --el-scrollbar-hover-opacity: 1;
  --el-transition-duration: 0.3s;
}

// \u4E3B\u8981\u6837\u5F0F
.@{namespace}-scrollbar {
  overflow: hidden;
  position: relative;
  height: 100%;

  // wrap \u5143\u7D20
  &__wrap {
    overflow: auto;
    height: 100%;

    // hidden-default \u4FEE\u9970\u7B26
    &--hidden-default {
      scrollbar-width: none;
      &::-webkit-scrollbar {
        display: none;
      }
    }
  }

  // thumb \u5143\u7D20
  &__thumb {
    position: relative;
    display: block;
    width: 0;
    height: 0;
    cursor: pointer;
    border-radius: inherit;
    background-color: var(--el-scrollbar-bg-color);
    transition: var(--el-transition-duration) background-color;
    opacity: var(--el-scrollbar-opacity);

    &:hover {
      background-color: var(--el-scrollbar-hover-bg-color);
      opacity: var(--el-scrollbar-hover-opacity);
    }
  }

  // bar \u5143\u7D20
  &__bar {
    position: absolute;
    right: 2px;
    bottom: 2px;
    z-index: 1;
    border-radius: 4px;

    // vertical \u72B6\u6001
    &.is-vertical {
      width: 6px;
      top: 2px;

      > div {
        width: 100%;
      }
    }

    // horizontal \u72B6\u6001
    &.is-horizontal {
      height: 6px;
      left: 2px;

      > div {
        height: 100%;
      }
    }
  }
}

// fade \u52A8\u753B
.@{namespace}-scrollbar-fade {
  &-enter-active {
    transition: opacity 340ms ease-out;
  }

  &-leave-active {
    transition: opacity 120ms ease-out;
  }

  &-enter-from,
  &-leave-active {
    opacity: 0;
  }
}
`},36933:function(m,n){n.Z=`import React from 'react';
import Scrollbar from '../../src';
import '../../assets/style.less';

export default function App() {
  return (
    <div>
      <div className="wrapper">
        <Scrollbar height="400px" always>
          {Array.from({ length: 20 }, (_, index) => (
            <p key={index} className="scrollbar-demo-item">
              {index + 1}
            </p>
          ))}
        </Scrollbar>
      </div>
    </div>
  );
}
`},7575:function(m,n){n.Z=`import React from 'react';
import Scrollbar from '../../src';

const itemStyle: React.CSSProperties = {
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  width: '100px',
  height: '50px',
  margin: '10px',
  textAlign: 'center',
  borderRadius: '4px',
  background: 'rgb(235.9, 245.3, 255)',
  color: '#409eff',
};
export default function App() {
  return (
    <div>
      <div className="wrapper">
        <Scrollbar>
          <div
            style={{
              display: 'flex',
              width: 'fit-content',
            }}
          >
            {Array.from({ length: 20 }, (_, index) => (
              <p key={index} style={itemStyle}>
                {index + 1}
              </p>
            ))}
          </div>
        </Scrollbar>
      </div>
    </div>
  );
}
`},32620:function(m,n){n.Z=`import React from 'react';
import Scrollbar, { type ScrollbarRef } from '../../src';
import '../../assets/style.less';

export default function App() {
  const [num, setNum] = React.useState(30);
  const [loading, setLoading] = React.useState(false);
  const scrollbarRef = React.useRef<ScrollbarRef>(null);

  const loadMore = React.useCallback(
    (direction) => {
      if (direction === 'bottom' && !loading) {
        console.log('Loading more items...', num); // \u8C03\u8BD5\u65E5\u5FD7
        setLoading(true);

        // \u6A21\u62DF\u5F02\u6B65\u52A0\u8F7D
        setTimeout(() => {
          setNum((prev) => prev + 5);
          setLoading(false);
        }, 500); // \u589E\u52A0\u5EF6\u65F6\u4EE5\u4FBF\u89C2\u5BDF\u6548\u679C
      }
    },
    [loading, num],
  );

  return (
    <div>
      <div className="wrapper">
        <Scrollbar height="400px" onEndReached={loadMore}>
          {Array.from({ length: num }, (_, index) => (
            <p key={index} className="scrollbar-demo-item">
              {index + 1}
            </p>
          ))}
        </Scrollbar>
      </div>
    </div>
  );
}
`},35324:function(m,n){n.Z=`import React from 'react';
import Scrollbar, { type ScrollbarRef } from '../../src';
import '../../assets/style.less';
import 'rc-slider/assets/index.css';
import Slider from 'rc-slider';

export default function App() {
  const scrollbarRef = React.useRef<ScrollbarRef>(null);

  return (
    <div>
      <div className="wrapper">
        <Scrollbar ref={scrollbarRef} height="400px" always>
          {Array.from({ length: 20 }, (_, index) => (
            <p key={index} className="scrollbar-demo-item">
              {index + 1}
            </p>
          ))}
        </Scrollbar>

        <Slider
          max={20 * 60} // items height and margin
          onChange={(e) => {
            if (scrollbarRef.current) {
              scrollbarRef.current.setScrollTop(e as number);
            }
          }}
        />
      </div>
    </div>
  );
}
`},10700:function(m,n){n.Z=`import React, { useRef, useEffect, useCallback } from 'react';
import { useResizeObserver, useEventListener, useNamespace } from './hooks';
import { addUnit, isNumber, isObject } from './utils';
import Bar, { BarRef } from './bar';
import { ScrollbarContext } from './context';
import type { ScrollbarProps } from './interface';
// \u7C7B\u578B\u5B9A\u4E49

export type ScrollbarDirection = 'top' | 'bottom' | 'left' | 'right';

export interface ScrollbarRef {
  wrapRef: React.RefObject<HTMLDivElement>;
  update: () => void;
  scrollTo: {
    (x: number, y?: number): void;
    (options: ScrollToOptions): void;
  };
  setScrollTop: (value: number) => void;
  setScrollLeft: (value: number) => void;
  handleScroll: () => void;
}

const Scrollbar = React.forwardRef<ScrollbarRef, ScrollbarProps>(
  (
    {
      height,
      maxHeight,
      native = false,
      wrapStyle = {},
      wrapClass = '',
      viewClass = '',
      viewStyle = {},
      noresize = false,
      tag: Tag = 'div',
      always = false,
      minSize = 12,
      tabindex,
      id,
      role,
      ariaLabel,
      ariaOrientation,
      children,
      onScroll,
      onEndReached,
    },
    ref,
  ) => {
    const ns = useNamespace('scrollbar');

    // Refs
    const scrollbarRef = useRef<HTMLDivElement>(null);
    const wrapRef = useRef<HTMLDivElement>(null);
    const resizeRef = useRef<HTMLDivElement>(null);
    const barRef = useRef<BarRef>(null);

    // State
    const wrapScrollTop = useRef(0);
    const wrapScrollLeft = useRef(0);
    const direction = useRef<ScrollbarDirection>('top');

    // Resize observers
    const stopResizeObserver = useRef<(() => void) | undefined>();
    const stopResizeListener = useRef<(() => void) | undefined>();

    // Computed styles
    const computedWrapStyle = React.useMemo<React.CSSProperties>(() => {
      const style: React.CSSProperties = { ...wrapStyle };
      if (height) style.height = addUnit(height);
      if (maxHeight) style.maxHeight = addUnit(maxHeight);
      return style;
    }, [height, maxHeight, wrapStyle]);

    const wrapClassName = React.useMemo(() => {
      return [
        wrapClass,
        ns.e('wrap'),
        !native ? ns.em('wrap', 'hidden-default') : '',
      ]
        .filter(Boolean)
        .join(' ');
    }, [wrapClass, ns, native]);

    const resizeClassName = React.useMemo(() => {
      return [ns.e('view'), viewClass].filter(Boolean).join(' ');
    }, [ns, viewClass]);

    // Calculate arrived states
    const calculateArrivedStates = useCallback(
      (
        wrapElement: HTMLDivElement,
        currentTop: number,
        currentLeft: number,
        prevTop: number,
        prevLeft: number,
      ) => {
        const tolerance = 1; // \u6DFB\u52A01px\u7684\u5BB9\u5DEE\uFF0C\u907F\u514D\u6D6E\u70B9\u6570\u7CBE\u5EA6\u95EE\u9898

        return {
          bottom:
            currentTop + wrapElement.clientHeight >=
            wrapElement.scrollHeight - tolerance,
          top: currentTop <= tolerance,
          right:
            currentLeft + wrapElement.clientWidth >=
            wrapElement.scrollWidth - tolerance,
          left: currentLeft <= tolerance,
        };
      },
      [],
    );

    // Handle scroll
    const handleScroll = useCallback(() => {
      if (wrapRef.current) {
        barRef.current?.handleScroll(wrapRef.current);

        const prevTop = wrapScrollTop.current;
        const prevLeft = wrapScrollLeft.current;
        wrapScrollTop.current = wrapRef.current.scrollTop;
        wrapScrollLeft.current = wrapRef.current.scrollLeft;

        const arrivedStates = calculateArrivedStates(
          wrapRef.current,
          wrapScrollTop.current,
          wrapScrollLeft.current,
          prevTop,
          prevLeft,
        );

        // \u66F4\u65B0\u65B9\u5411\u5224\u65AD\u903B\u8F91
        let currentDirection = direction.current;
        if (
          Math.abs(prevTop - wrapScrollTop.current) >
          Math.abs(prevLeft - wrapScrollLeft.current)
        ) {
          currentDirection = wrapScrollTop.current > prevTop ? 'bottom' : 'top';
        } else if (prevLeft !== wrapScrollLeft.current) {
          currentDirection =
            wrapScrollLeft.current > prevLeft ? 'right' : 'left';
        }
        direction.current = currentDirection;

        onScroll?.({
          scrollTop: wrapScrollTop.current,
          scrollLeft: wrapScrollLeft.current,
        });

        // \u68C0\u67E5\u662F\u5426\u5230\u8FBE\u8FB9\u754C\u5E76\u89E6\u53D1 onEndReached
        if (arrivedStates[currentDirection]) {
          onEndReached?.(currentDirection);
        }
      }
    }, [onScroll, onEndReached, calculateArrivedStates]);

    // ScrollTo overloads
    const scrollTo = useCallback(
      ((arg1: unknown, arg2?: number) => {
        if (!wrapRef.current) {
          console.warn('Scrollbar wrap element is not available');
          return;
        }

        try {
          if (isObject(arg1)) {
            wrapRef.current.scrollTo(arg1 as ScrollToOptions);
          } else if (isNumber(arg1) && isNumber(arg2)) {
            wrapRef.current.scrollTo(arg1, arg2);
          } else {
            console.warn('Invalid arguments for scrollTo');
          }
        } catch (error) {
          console.error('ScrollTo failed:', error);
        }
      }) as ScrollbarRef['scrollTo'],
      [],
    );

    const setScrollTop = useCallback((value: number) => {
      if (!isNumber(value)) {
        console.warn('ElScrollbar: value must be a number');
        return;
      }
      if (wrapRef.current) {
        wrapRef.current.scrollTop = value;
      }
    }, []);

    const setScrollLeft = useCallback((value: number) => {
      if (!isNumber(value)) {
        console.warn('ElScrollbar: value must be a number');
        return;
      }
      if (wrapRef.current) {
        wrapRef.current.scrollLeft = value;
      }
    }, []);

    const update = useCallback(() => {
      barRef.current?.update();
    }, []);

    const dimensions = useResizeObserver(resizeRef, !noresize);
    useEventListener(!noresize ? window : null, 'resize', update);

    // Setup resize observers
    useEffect(() => {
      if (dimensions && !noresize) {
        update();
      }
    }, [dimensions, noresize, update]);

    // Watch height changes
    useEffect(() => {
      if (!native) {
        // Use setTimeout to simulate nextTick
        setTimeout(() => {
          update();
          if (wrapRef.current) {
            barRef.current?.handleScroll(wrapRef.current);
          }
        }, 0);
      }
    }, [maxHeight, height, native, update]);

    // Initial update on mount
    useEffect(() => {
      if (!native) {
        setTimeout(() => {
          update();
        }, 0);
      }
    }, [native, update]);

    // Cleanup on unmount
    useEffect(() => {
      return () => {
        stopResizeObserver.current?.();
        stopResizeListener.current?.();
      };
    }, []);

    // Context value
    const contextValue = React.useMemo(
      () => ({
        scrollbarElement: scrollbarRef.current,
        wrapElement: wrapRef.current,
      }),
      [scrollbarRef.current, wrapRef.current],
    );

    // Expose methods
    React.useImperativeHandle(
      ref,
      () => ({
        wrapRef,
        update,
        scrollTo,
        setScrollTop,
        setScrollLeft,
        handleScroll,
      }),
      [update, scrollTo, setScrollTop, setScrollLeft, handleScroll],
    );

    return (
      <ScrollbarContext.Provider value={contextValue}>
        <div ref={scrollbarRef} className={ns.b()}>
          <div
            ref={wrapRef}
            className={wrapClassName}
            style={computedWrapStyle}
            tabIndex={tabindex}
            onScroll={handleScroll}
          >
            <div
              id={id}
              ref={resizeRef}
              className={resizeClassName}
              style={viewStyle}
              role={role}
              aria-label={ariaLabel}
              aria-orientation={ariaOrientation}
            >
              {children}
            </div>
          </div>
          {!native && <Bar ref={barRef} always={always} minSize={minSize} />}
        </div>
      </ScrollbarContext.Provider>
    );
  },
);

Scrollbar.displayName = 'Scrollbar';

export default Scrollbar;
`},75998:function(m,n){n.Z=`import React, {
  useRef,
  useImperativeHandle,
  forwardRef,
  useEffect,
  useCallback,
  useMemo,
  useState,
  CSSProperties,
} from 'react';
import { useEventListener, useNamespace } from './hooks';
import { isClient } from './utils';
import { ScrollbarContext } from './context';
import { BAR_MAP, renderThumbStyle } from './util';

// \u7C7B\u578B\u5B9A\u4E49
interface ThumbProps {
  vertical?: boolean;
  size?: string;
  move?: number;
  ratio?: number;
  always?: boolean;
}

export interface ThumbRef {
  // \u53EF\u4EE5\u66B4\u9732\u9700\u8981\u7684\u65B9\u6CD5
}

const COMPONENT_NAME = 'Thumb';

const Thumb = forwardRef<ThumbRef, ThumbProps>(
  (
    { vertical = false, size = '', move = 0, ratio = 1, always = false },
    ref,
  ) => {
    const scrollbar = React.useContext(ScrollbarContext);
    const ns = useNamespace('scrollbar');

    if (!scrollbar) {
      throw new Error(\`\${COMPONENT_NAME}: can not inject scrollbar context\`);
    }

    // Refs
    const instanceRef = useRef<HTMLDivElement>(null);
    const thumbRef = useRef<HTMLDivElement>(null);

    // State
    const [thumbState, setThumbState] = useState<
      Partial<Record<'X' | 'Y', number>>
    >({});
    const [visible, setVisible] = useState(false);

    // Variables
    const cursorDown = useRef(false);
    const cursorLeave = useRef(false);
    const baseScrollHeight = useRef(0);
    const baseScrollWidth = useRef(0);
    const originalOnSelectStart = useRef<
      ((this: GlobalEventHandlers, ev: Event) => any) | null
    >(isClient() ? document.onselectstart : null);

    // Computed values
    const bar = useMemo(
      () => BAR_MAP[vertical ? 'vertical' : 'horizontal'],
      [vertical],
    );

    const thumbStyle = useMemo<CSSProperties>(
      () =>
        renderThumbStyle({
          size,
          move,
          bar,
        }),
      [size, move, bar],
    );

    const offsetRatio = useMemo(() => {
      if (!instanceRef.current || !thumbRef.current || !scrollbar.wrapElement) {
        return 1;
      }

      const instanceOffset = instanceRef.current[
        bar.offset as keyof HTMLElement
      ] as number;
      const wrapScrollSize = scrollbar.wrapElement[
        bar.scrollSize as keyof HTMLElement
      ] as number;
      const thumbOffset = thumbRef.current[
        bar.offset as keyof HTMLElement
      ] as number;

      if (
        instanceOffset === 0 ||
        wrapScrollSize === 0 ||
        thumbOffset === 0 ||
        ratio === 0
      ) {
        return 1;
      }

      return instanceOffset ** 2 / wrapScrollSize / ratio / thumbOffset;
    }, [bar, ratio, scrollbar.wrapElement]);

    // Event handlers
    const restoreOnselectstart = useCallback(() => {
      if (document.onselectstart !== originalOnSelectStart.current) {
        document.onselectstart = originalOnSelectStart.current;
      }
    }, []);

    const mouseUpDocumentHandler = useCallback(() => {
      cursorDown.current = false;
      document.removeEventListener('mousemove', mouseMoveDocumentHandler);
      document.removeEventListener('mouseup', mouseUpDocumentHandler);
      restoreOnselectstart();
      if (cursorLeave.current) {
        setVisible(false);
      }
    }, [bar.axis, restoreOnselectstart]);

    const mouseMoveDocumentHandler = useCallback(
      (e: MouseEvent) => {
        if (!instanceRef.current || !thumbRef.current || !scrollbar.wrapElement)
          return;
        if (cursorDown.current === false) return;

        const prevPage = thumbState[bar.axis];
        if (!prevPage) return;

        const offset =
          (((instanceRef.current.getBoundingClientRect()[
            bar.direction as keyof DOMRect
          ] as number) - e[bar.client as keyof MouseEvent]) as number) * -1;
        const thumbClickPosition =
          (thumbRef.current[bar.offset as keyof HTMLElement] as number) -
          prevPage;
        const thumbPositionPercentage =
          ((offset - thumbClickPosition) * 100 * offsetRatio) /
          (instanceRef.current[bar.offset as keyof HTMLElement] as number);

        if (bar.scroll === 'scrollLeft') {
          scrollbar.wrapElement[bar.scroll] =
            (thumbPositionPercentage * baseScrollWidth.current) / 100;
        } else {
          scrollbar.wrapElement[bar.scroll as 'scrollTop'] =
            (thumbPositionPercentage * baseScrollHeight.current) / 100;
        }
      },
      [thumbState, bar, offsetRatio, scrollbar.wrapElement],
    );

    const startDrag = useCallback(
      (e: MouseEvent) => {
        if (!scrollbar.wrapElement) return;

        e.stopImmediatePropagation();
        cursorDown.current = true;
        baseScrollHeight.current = scrollbar.wrapElement.scrollHeight;
        baseScrollWidth.current = scrollbar.wrapElement.scrollWidth;
        document.addEventListener('mousemove', mouseMoveDocumentHandler);
        document.addEventListener('mouseup', mouseUpDocumentHandler);
        originalOnSelectStart.current = document.onselectstart;
        document.onselectstart = () => false;
      },
      [scrollbar.wrapElement, mouseMoveDocumentHandler, mouseUpDocumentHandler],
    );

    const clickThumbHandler = useCallback(
      (e: React.MouseEvent<HTMLDivElement>) => {
        // prevent click event of middle and right button
        e.stopPropagation();
        if (e.ctrlKey || [1, 2].includes(e.button)) return;

        window.getSelection()?.removeAllRanges();
        startDrag(e.nativeEvent);

        const el = e.currentTarget;
        if (!el) return;

        const newState = {
          ...thumbState,
          [bar.axis]:
            (el[bar.offset as keyof HTMLElement] as number) -
            (((e.nativeEvent[bar.client as keyof MouseEvent] as number) -
              el.getBoundingClientRect()[
                bar.direction as keyof DOMRect
              ]) as number),
        };
        setThumbState(newState);
      },
      [startDrag, thumbState, bar],
    );

    const clickTrackHandler = useCallback(
      (e: React.MouseEvent<HTMLDivElement>) => {
        if (!thumbRef.current || !instanceRef.current || !scrollbar.wrapElement)
          return;

        const target = e.target as HTMLElement;
        const offset = Math.abs(
          ((target.getBoundingClientRect()[
            bar.direction as keyof DOMRect
          ] as number) -
            e.nativeEvent[bar.client as keyof MouseEvent]) as number,
        );
        const thumbHalf =
          (thumbRef.current[bar.offset as keyof HTMLElement] as number) / 2;
        const thumbPositionPercentage =
          ((offset - thumbHalf) * 100 * offsetRatio) /
          (instanceRef.current[bar.offset as keyof HTMLElement] as number);

        scrollbar.wrapElement[bar.scroll as 'scrollTop' | 'scrollLeft'] =
          (thumbPositionPercentage *
            (scrollbar.wrapElement[
              bar.scrollSize as keyof HTMLElement
            ] as number)) /
          100;
      },
      [bar, offsetRatio, scrollbar.wrapElement],
    );

    const mouseMoveScrollbarHandler = useCallback(() => {
      cursorLeave.current = false;
      setVisible(!!size);
    }, [size]);

    const mouseLeaveScrollbarHandler = useCallback(() => {
      cursorLeave.current = true;
      setVisible(cursorDown.current);
    }, []);

    // Event listeners
    useEventListener(
      scrollbar.scrollbarElement,
      'mousemove',
      mouseMoveScrollbarHandler,
    );

    useEventListener(
      scrollbar.scrollbarElement,
      'mouseleave',
      mouseLeaveScrollbarHandler,
    );

    // Cleanup
    useEffect(() => {
      return () => {
        restoreOnselectstart();
        document.removeEventListener('mouseup', mouseUpDocumentHandler);
      };
    }, [restoreOnselectstart, mouseUpDocumentHandler]);

    // Expose methods
    useImperativeHandle(ref, () => ({}), []);

    // CSS classes
    const barClassName = \`\${ns.e('bar')} \${ns.is(bar.key)}\`;
    const thumbClassName = ns.e('thumb');

    return (
      <div
        ref={instanceRef}
        className={barClassName}
        style={{
          opacity: always || visible ? 1 : 0,
          transition: 'opacity 120ms ease-out',
          display: always || visible ? 'block' : 'none',
        }}
        onMouseDown={clickTrackHandler}
        onClick={(e) => e.stopPropagation()}
      >
        <div
          ref={thumbRef}
          className={thumbClassName}
          style={thumbStyle}
          onMouseDown={clickThumbHandler}
        />
      </div>
    );
  },
);

Thumb.displayName = 'Thumb';

export default Thumb;
`},32390:function(m,n){n.Z=`import React from 'react';
import Thumb from './Thumb';
import { GAP } from './util';
import { ScrollbarContext } from './context';

interface BarProps {
  minSize?: number;
  always?: boolean;
}

export interface BarRef {
  handleScroll: (wrap: HTMLDivElement) => void;
  update: () => void;
}

const Bar = React.forwardRef<BarRef, BarProps>(
  ({ minSize = 12, always = false }, ref) => {
    // \u83B7\u53D6 scrollbar \u4E0A\u4E0B\u6587
    const scrollbar = React.useContext(ScrollbarContext);

    // \u72B6\u6001\u7BA1\u7406\uFF08\u76F8\u5F53\u4E8E Vue \u7684 ref\uFF09
    const moveX = React.useRef(0);
    const moveY = React.useRef(0);
    const sizeWidth = React.useRef('');
    const sizeHeight = React.useRef('');
    const ratioY = React.useRef(1);
    const ratioX = React.useRef(1);

    // \u5F3A\u5236\u91CD\u6E32\u67D3\u7684 hook
    const [, forceUpdate] = React.useReducer((x) => x + 1, 0);

    // \u9632\u6B62\u9664\u96F6\u7684\u5B89\u5168\u9664\u6CD5
    const safeDiv = (a: number, b: number) => (b === 0 ? 1 : a / b);

    const handleScroll = (wrap: HTMLDivElement) => {
      if (wrap) {
        const offsetHeight = wrap.offsetHeight - GAP;
        const offsetWidth = wrap.offsetWidth - GAP;

        moveY.current =
          offsetHeight === 0
            ? 0
            : ((wrap.scrollTop * 100) / offsetHeight) * ratioY.current;
        moveX.current =
          offsetWidth === 0
            ? 0
            : ((wrap.scrollLeft * 100) / offsetWidth) * ratioX.current;

        forceUpdate(); // \u89E6\u53D1\u91CD\u6E32\u67D3
      }
    };

    const update = () => {
      const wrap = scrollbar?.wrapElement;
      if (!wrap) return;

      const offsetHeight = wrap.offsetHeight - GAP;
      const offsetWidth = wrap.offsetWidth - GAP;

      const originalHeight = safeDiv(offsetHeight ** 2, wrap.scrollHeight);
      const originalWidth = safeDiv(offsetWidth ** 2, wrap.scrollWidth);
      const height = Math.max(originalHeight, minSize);
      const width = Math.max(originalWidth, minSize);

      // \u8BA1\u7B97\u6BD4\u4F8B\uFF0C\u9632\u6B62\u5206\u6BCD\u4E3A 0
      const h1 = offsetHeight - originalHeight;
      const h2 = offsetHeight - height;
      const w1 = offsetWidth - originalWidth;
      const w2 = offsetWidth - width;

      ratioY.current = safeDiv(originalHeight, h1) / safeDiv(height, h2);
      ratioX.current = safeDiv(originalWidth, w1) / safeDiv(width, w2);

      sizeHeight.current = height + GAP < offsetHeight ? \`\${height}px\` : '';
      sizeWidth.current = width + GAP < offsetWidth ? \`\${width}px\` : '';

      forceUpdate(); // \u89E6\u53D1\u91CD\u6E32\u67D3
    };

    // \u66B4\u9732\u65B9\u6CD5\u7ED9\u7236\u7EC4\u4EF6\uFF08\u76F8\u5F53\u4E8E Vue \u7684 defineExpose\uFF09
    React.useImperativeHandle(ref, () => ({
      handleScroll,
      update,
    }));

    return (
      <>
        <Thumb
          move={moveX.current}
          ratio={ratioX.current}
          size={sizeWidth.current}
          always={always}
        />
        <Thumb
          move={moveY.current}
          ratio={ratioY.current}
          size={sizeHeight.current}
          vertical
          always={always}
        />
      </>
    );
  },
);

Bar.displayName = 'Bar';

export default Bar;
`},79507:function(m,n){n.Z=`import React from 'react';
export interface ScrollbarContext {
  scrollbarElement: HTMLDivElement | null;
  wrapElement: HTMLDivElement | null;
}

export const ScrollbarContext = React.createContext<ScrollbarContext | null>(
  null,
);
`},36546:function(m,n){n.Z="import useResizeObserver from './useResizeObserver';\nimport useEventListener from './useEventListener';\n\nconst useNamespace = (block: string) => ({\n  b: () => `el-${block}`,\n  e: (element: string) => `el-${block}__${element}`,\n  em: (element: string, modifier: string) =>\n    `el-${block}__${element}--${modifier}`,\n  is: (name: string) => {\n    return name ? `is-${name}` : '';\n  },\n});\n\nexport { useResizeObserver, useEventListener, useNamespace };\n"},66476:function(m,n){n.Z=`import { useEffect } from 'react';

const useEventListener = (
  target: Window | HTMLElement | null,
  event: string,
  handler: () => void,
): (() => void) => {
  useEffect(() => {
    if (!target) return;

    target.addEventListener(event, handler);
    return () => {
      target.removeEventListener(event, handler);
    };
  }, [target, event, handler]);

  return () => {
    if (!target) return;
    target.removeEventListener(event, handler);
  };
};

export default useEventListener;
`},35130:function(m,n){n.Z=`import { useEffect, useState, RefObject } from 'react';

interface Dimensions {
  width: number;
  height: number;
}

const useResizeObserver = (
  ref: RefObject<HTMLElement>,
  enabled: boolean = true,
): Dimensions | null => {
  const [dimensions, setDimensions] = useState<Dimensions | null>(null);

  useEffect(() => {
    if (!enabled || !ref.current) return;

    const observer = new ResizeObserver((entries) => {
      const { width, height } = entries[0].contentRect;
      setDimensions({ width, height });
    });

    observer.observe(ref.current);

    return () => {
      observer.disconnect();
    };
  }, [ref, enabled]);

  return dimensions;
};

export default useResizeObserver;
`},27863:function(m,n){n.Z=`import ScrollBar from './ScrollBar';
export type { ScrollbarProps } from './interface';
export type { ScrollbarRef } from './ScrollBar';
export default ScrollBar;
`},99547:function(m,n){n.Z=`import type { CSSProperties } from 'react'
import type { ThumbProps } from './interface'

export const GAP = 4 // top 2 + bottom 2 of bar instance

export const BAR_MAP = {
  vertical: {
    offset: 'offsetHeight',
    scroll: 'scrollTop',
    scrollSize: 'scrollHeight',
    size: 'height',
    key: 'vertical',
    axis: 'Y',
    client: 'clientY',
    direction: 'top',
  },
  horizontal: {
    offset: 'offsetWidth',
    scroll: 'scrollLeft',
    scrollSize: 'scrollWidth',
    size: 'width',
    key: 'horizontal',
    axis: 'X',
    client: 'clientX',
    direction: 'left',
  },
} as const

export const renderThumbStyle = ({
  move,
  size,
  bar,
}: Pick<ThumbProps, 'move' | 'size'> & {
  bar: typeof BAR_MAP[keyof typeof BAR_MAP]
}): CSSProperties => ({
  [bar.size]: size,
  transform: \`translate\${bar.axis}(\${move}%)\`,
})
`},9143:function(m,n){n.Z=`export const isNumber = (val: any): val is number => typeof val === 'number';
export const isString = (val: any): val is string => typeof val === 'string';

export function isObject(obj: any): boolean {
  return obj !== null && typeof obj === 'object';
}

export const isStringNumber = (val: string): boolean => {
  if (!isString(val)) {
    return false;
  }
  return !Number.isNaN(Number(val));
};

export function addUnit(value?: string | number, defaultUnit = 'px') {
  if (!value) return '';
  if (isNumber(value) || isStringNumber(value)) {
    return \`\${value}\${defaultUnit}\`;
  } else if (isString(value)) {
    return value;
  }
  console.error('binding value must be a string or number');
}
export function isClient() {
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
`}}]);
